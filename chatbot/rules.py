import unicodedata
from .models import EstadoConversacion, TipoConsulta
from .states import conversation_manager
from config.company_profiles import get_urgency_redirect_message
from services.error_reporter import error_reporter, ErrorTrigger
from services.metrics_service import metrics_service

def normalizar_texto(texto: str) -> str:
    """
    Normaliza texto: lowercase + sin acentos + sin espacios + sin puntos
    """
    texto = texto.lower().strip()
    # Remover acentos
    sin_acentos = ''.join(c for c in unicodedata.normalize('NFD', texto) 
                          if unicodedata.category(c) != 'Mn')
    # Remover espacios y puntos para mejor matching (bsas = bs as = bs. as.)
    return sin_acentos.replace(' ', '').replace('.', '')

# Mapeo de sin√≥nimos para validaci√≥n geogr√°fica (solo min√∫sculas, se normalizan autom√°ticamente)
SINONIMOS_CABA = [
    'caba', 'c.a.b.a', 'ciudad autonoma', 
    'capital', 'capital federal', 'microcentro', 'palermo', 
    'recoleta', 'san telmo', 'puerto madero', 'belgrano',
    'barracas', 'boca', 'caballito', 'flores', 'once',
    'retiro', 'villa crespo', 'almagro', 'balvanera'
]

SINONIMOS_PROVINCIA = [
    'provincia', 'prov', 'buenos aires', 'bs as', 'bs. as.',
    'gba', 'gran buenos aires', 'zona norte', 'zona oeste', 
    'zona sur', 'la plata', 'quilmes', 'lomas de zamora',
    'san isidro', 'tigre', 'pilar', 'escobar', 'moreno',
    'merlo', 'moron', 'tres de febrero', 'vicente lopez',
    'avellaneda', 'lanus', 'berazategui', 'florencio varela',
    'ramos mejia'
]

# Sets pre-computados normalizados para b√∫squeda O(1)
SINONIMOS_CABA_NORM = {normalizar_texto(s) for s in SINONIMOS_CABA}
SINONIMOS_PROVINCIA_NORM = {normalizar_texto(s) for s in SINONIMOS_PROVINCIA}

class ChatbotRules:
    
    @staticmethod
    def _detectar_volver_menu(mensaje: str) -> bool:
        """
        Detecta si el usuario quiere volver al men√∫ principal
        """
        mensaje_lower = mensaje.lower().strip()
        frases_menu = [
            'volver', 'menu', 'men√∫', 'inicio', 'empezar de nuevo',
            'me equivoqu√©', 'me equivoque', 'error', 'atr√°s', 'atras',
            'menu principal', 'men√∫ principal', 'opci√≥n', 'opcion',
            'elegir otra', 'cambiar opci√≥n', 'cambiar opcion'
        ]
        
        return any(frase in mensaje_lower for frase in frases_menu)
    
    @staticmethod
    def get_mensaje_inicial() -> str:
        return """¬°Hola! üëã Mi nombre es Eva, soy la asistente virtual de Argenfuego.

¬øEn qu√© puedo ayudarte hoy? Por favor selecciona una opci√≥n:

1Ô∏è‚É£ Solicitar un presupuesto
2Ô∏è‚É£ Reportar una urgencia
3Ô∏è‚É£ Otras consultas

Responde con el n√∫mero de la opci√≥n que necesitas üì±"""
    
    @staticmethod
    def get_mensaje_inicial_personalizado(nombre_usuario: str = "") -> str:
        """
        Genera saludo personalizado est√°tico con nombre si est√° disponible
        """
        # Saludo personalizado simple sin OpenAI
        if nombre_usuario:
            saludo = f"¬°Hola {nombre_usuario}! üëãüèª Mi nombre es Eva üë©üèª‚Äçü¶±, soy la asistente virtual de Argenfuego."
        else:
            saludo = "¬°Hola! üëãüèª Mi nombre es Eva üë©üèª‚Äçü¶±, soy la asistente virtual de Argenfuego."
        
        # Men√∫ de opciones
        menu = """

¬øEn qu√© puedo ayudarte hoy? Por favor selecciona una opci√≥n:

1Ô∏è‚É£ Solicitar un presupuesto
2Ô∏è‚É£ Reportar una urgencia
3Ô∏è‚É£ Otras consultas

Responde con el n√∫mero de la opci√≥n que necesitas üì±"""
        
        return saludo + menu
    
    @staticmethod
    def get_saludo_inicial(nombre_usuario: str = "") -> str:
        """
        Primera parte del saludo: solo el saludo y presentaci√≥n de Eva
        """
        if nombre_usuario:
            return f"¬°Hola {nombre_usuario}! üëãüèª Mi nombre es *Eva*"
        else:
            return "¬°Hola! üëãüèª Mi nombre es *Eva*"
    
    @staticmethod
    def get_presentacion_empresa() -> str:
        """
        Segunda parte del saludo: presentaci√≥n de la empresa y men√∫
        """
        from config.company_profiles import get_active_company_profile
        profile = get_active_company_profile()
        company_name = profile['name']
        
        return f"""Soy la asistente virtual de {company_name}.

¬øEn qu√© puedo ayudarte hoy? Por favor selecciona una opci√≥n:

1Ô∏è‚É£ Solicitar un presupuesto
2Ô∏è‚É£ Reportar una urgencia
3Ô∏è‚É£ Otras consultas

Responde con el n√∫mero de la opci√≥n que necesitas üì±"""
    
    @staticmethod
    def _enviar_flujo_saludo_completo(numero_telefono: str, nombre_usuario: str = "") -> str:
        """
        Env√≠a el flujo completo de saludo: texto + imagen + texto
        Retorna solo el primer mensaje, los otros se env√≠an en background
        """
        from services.twilio_service import twilio_service
        from config.company_profiles import get_active_company_profile
        import threading
        import time
        
        # 1. Enviar sticker PRIMERO (para que llegue como 2do mensaje)
        def enviar_sticker_primero():
            try:
                import logging
                logger = logging.getLogger(__name__)
                logger.info(f"DEBUG: Enviando sticker PRIMERO para {numero_telefono}")
                
                profile = get_active_company_profile()
                company_name = profile['name'].lower()
                image_url = f"https://raw.githubusercontent.com/Csuarezgurruchaga/argenfuego-chatbot/main/assets/{company_name}.webp"
                
                logger.info(f"DEBUG: Enviando sticker (1er mensaje): {image_url}")
                success = twilio_service.send_whatsapp_media(numero_telefono, image_url)
                logger.info(f"DEBUG: Sticker enviado exitosamente: {success}")
                
            except Exception as e:
                import logging
                logger = logging.getLogger(__name__)
                logger.error(f"Error enviando sticker: {str(e)}")
        
        # 2. Enviar saludo y men√∫ en background
        def enviar_saludo_y_menu():
            try:
                import logging
                logger = logging.getLogger(__name__)
                logger.info(f"DEBUG: Enviando saludo y men√∫ para {numero_telefono}")
                
                # 2. Enviar saludo (2do mensaje)
                saludo = ChatbotRules.get_saludo_inicial(nombre_usuario)
                logger.info(f"DEBUG: Enviando saludo (2do mensaje)")
                twilio_service.send_whatsapp_message(numero_telefono, saludo)
                
                # 3. Delay de 2.5 segundos para asegurar que el saludo se procese
                logger.info(f"DEBUG: Esperando 2.5s para que el saludo se procese...")
                time.sleep(2.5)
                
                # 4. Enviar men√∫ (3er mensaje)
                menu_mensaje = ChatbotRules.get_presentacion_empresa()
                logger.info(f"DEBUG: Enviando men√∫ (3er mensaje)")
                twilio_service.send_whatsapp_message(numero_telefono, menu_mensaje)
                logger.info(f"DEBUG: Flujo de saludo completo terminado")
                
            except Exception as e:
                import logging
                logger = logging.getLogger(__name__)
                logger.error(f"Error enviando imagen/presentaci√≥n: {str(e)}")
                # Fallback: enviar mensaje completo si falla
                mensaje_completo = ChatbotRules.get_mensaje_inicial_personalizado(nombre_usuario)
                twilio_service.send_whatsapp_message(numero_telefono, mensaje_completo)
        
        # Ejecutar ambos en background
        thread1 = threading.Thread(target=enviar_sticker_primero)
        thread1.daemon = True
        thread1.start()
        
        thread2 = threading.Thread(target=enviar_saludo_y_menu)
        thread2.daemon = True
        thread2.start()
        
        # Retornar mensaje vac√≠o ya que todo se env√≠a en background
        return ""
    
    @staticmethod
    def get_mensaje_recoleccion_datos_simplificado(tipo_consulta: TipoConsulta) -> str:
        return """üìß Email
üìç Direcci√≥n
üïí Horario de visita
üìù Qu√© necesitas

üí° Escribe "men√∫" si quieres volver al inicio."""
    
    @staticmethod
    def get_mensaje_inicio_secuencial(tipo_consulta: TipoConsulta) -> str:
        """Mensaje inicial para el flujo secuencial conversacional"""
        if tipo_consulta == TipoConsulta.OTRAS:
            return """Perfecto üëåüèª Para poder ayudarte de la mejor manera, me gustar√≠a conocer m√°s detalles sobre tu consulta.

üìù Por favor, cont√°nos qu√© necesitas (ej: informaci√≥n sobre productos, horarios de atenci√≥n, servicios, etc.)"""
        
        elif tipo_consulta == TipoConsulta.URGENCIA:
            return """Entiendo que tienes una urgencia üö® Para poder asistirte de inmediato, necesito conocer los detalles.

üìù Por favor, cont√°nos qu√© est√° sucediendo y c√≥mo podemos ayudarte urgentemente."""
        
        elif tipo_consulta == TipoConsulta.PRESUPUESTO:
            return """Perfecto üëåüèª Para poder preparar tu presupuesto de manera precisa, necesito conocer los detalles de lo que necesitas.

üìù Por favor, cont√°nos qu√© productos o servicios requieres (ej: cantidad de extintores, tipo, ubicaci√≥n, etc.)"""
        
        # Fallback para otros tipos
        return """Perfecto üëåüèª Para poder ayudarte de la mejor manera, necesito conocer m√°s detalles.

üìù Por favor, cont√°nos qu√© necesitas."""
    
    @staticmethod
    def get_mensaje_recoleccion_datos(tipo_consulta: TipoConsulta) -> str:
        consulta_texto = {
            TipoConsulta.PRESUPUESTO: "un presupuesto",
            TipoConsulta.VISITA_TECNICA: "coordinar una visita t√©cnica",
            TipoConsulta.URGENCIA: "atender tu urgencia",
            TipoConsulta.OTRAS: "resolver tu consulta"
        }
        
        return f"""Perfecto! Para poder ayudarte con {consulta_texto[tipo_consulta]}, necesito que me proporciones la siguiente informaci√≥n:

üìß *Email de contacto*
üìç *Direcci√≥n* 
üïí *Horario en que se puede visitar el lugar*
üìù *Cu√©ntanos m√°s sobre lo que necesitas*

Por favor env√≠ame toda esta informaci√≥n en un solo mensaje para poder proceder.

_üí° Tambi√©n puedes escribir "men√∫" para volver al men√∫ principal en cualquier momento._"""
    
    @staticmethod
    def get_mensaje_confirmacion(conversacion) -> str:
        datos = conversacion.datos_contacto
        tipo_texto = {
            TipoConsulta.PRESUPUESTO: "Presupuesto",
            TipoConsulta.VISITA_TECNICA: "Visita t√©cnica",
            TipoConsulta.URGENCIA: "Urgencia",
            TipoConsulta.OTRAS: "Consulta general"
        }
        
        mensaje_confirmacion = f"""üìã *Resumen de tu solicitud:*

üè∑Ô∏è *Tipo de consulta:* {tipo_texto[conversacion.tipo_consulta]}"""

        # Solo mostrar email si fue proporcionado (no es el valor por defecto)
        if datos.email and datos.email != "no_proporcionado@ejemplo.com":
            mensaje_confirmacion += f"""
üìß *Email:* {datos.email}"""

        # Para consultas que no sean OTRAS, mostrar campos adicionales solo si fueron proporcionados
        if conversacion.tipo_consulta != TipoConsulta.OTRAS:
            if datos.direccion and datos.direccion != "No proporcionada":
                mensaje_confirmacion += f"""
üìç *Direcci√≥n:* {datos.direccion}"""
            
            if datos.horario_visita and datos.horario_visita != "No especificado":
                mensaje_confirmacion += f"""
üïí *Horario de visita:* {datos.horario_visita}"""

        mensaje_confirmacion += f"""
üìù *Descripci√≥n:* {datos.descripcion}

¬øEs correcta toda la informaci√≥n? 

‚úÖ Responde *"SI"* para confirmar y enviar la solicitud
‚ùå Responde *"NO"* si hay algo que corregir ‚úèÔ∏è
‚Ü©Ô∏è Responde *"MENU"* para volver al men√∫ principal"""

        return mensaje_confirmacion
    
    @staticmethod
    def _get_texto_tipo_consulta(tipo_consulta: TipoConsulta) -> str:
        textos = {
            TipoConsulta.PRESUPUESTO: "un presupuesto",
            TipoConsulta.VISITA_TECNICA: "coordinar una visita t√©cnica", 
            TipoConsulta.URGENCIA: "atender una urgencia",
            TipoConsulta.OTRAS: "resolver una consulta"
        }
        return textos.get(tipo_consulta, "ayuda")
    
    @staticmethod
    def _get_pregunta_campo_individual(campo: str) -> str:
        preguntas = {
            'email': "üìß ¬øCu√°l es tu email de contacto?",
            'direccion': "üìç ¬øCu√°l es la direcci√≥n donde necesitas el servicio?(aclarar CABA o Provincia)",
            'horario_visita': "üïí ¬øCu√°l es tu horario disponible para la visita? (ej: lunes a viernes 9-17h)",
            'descripcion': """üìù Por favor, describe tu necesidad para que podamos preparar un presupuesto preciso. Puedes incluir:
‚Ä¢ Tipo de servicio (ej. mantenimiento anual, compra de equipo nuevo)
‚Ä¢ Tipo de equipo (ej. polvo qu√≠mico, CO2)
‚Ä¢ Capacidad (ej. 5 kg, 10 kg)
‚Ä¢ Cantidad (ej. 2 equipos)
"""
        }
        return preguntas.get(campo, "Por favor proporciona m√°s informaci√≥n.")
    
    @staticmethod
    def _get_pregunta_campo_secuencial(campo: str, tipo_consulta: TipoConsulta = None) -> str:
        """Preguntas espec√≠ficas para el flujo secuencial"""
        if campo == 'descripcion':
            if tipo_consulta == TipoConsulta.PRESUPUESTO:
                return """üìù Por favor, cont√°nos qu√© productos o servicios requieres (ej: cantidad de extintores, tipo, capacidad, etc.)"""
            elif tipo_consulta == TipoConsulta.URGENCIA:
                return """üìù Por favor, cont√°nos qu√© est√° sucediendo y c√≥mo podemos ayudarte urgentemente."""
            elif tipo_consulta == TipoConsulta.OTRAS:
                return """üìù Por favor, cont√°nos qu√© necesitas (ej: informaci√≥n sobre productos, horarios de atenci√≥n, servicios, etc.)"""
            else:
                return """üìù Por favor, cont√°nos qu√© necesitas."""
        
        # Preguntas para datos de contacto (opcionales)
        preguntas = {
            'email': "üìß ¬øCu√°l es tu email de contacto? (opcional, para poder ayudarte de manera m√°s efectiva)\n\nüí° Puedes escribir 'saltar' si prefieres no proporcionarlo.",
            'direccion': "üìç ¬øCu√°l es la direcci√≥n donde necesitas el servicio? (opcional)",
            'horario_visita': "üïí ¬øEn qu√© horario se puede visitar el lugar? (opcional)"
        }
        return preguntas.get(campo, "Por favor proporciona m√°s informaci√≥n.")
    
    @staticmethod
    def _get_mensaje_confirmacion_campo(campo: str, valor: str) -> str:
        """Mensajes de confirmaci√≥n para cada campo con emojis blancos"""
        confirmaciones = {
            'email': f"¬°Gracias! üôåüèª Anot√© tu email: {valor}",
            'direccion': f"Perfecto üëåüèª Direcci√≥n guardada: {valor}.",
            'horario_visita': f"Genial üôåüèª. Entonces el horario es: {valor}.",
            'descripcion': f"‚úÖ Perfecto! Descripci√≥n guardada: {valor}"
        }
        return confirmaciones.get(campo, f"‚úÖ {valor} guardado correctamente.")
    
    @staticmethod
    def _procesar_campo_secuencial(numero_telefono: str, mensaje: str) -> str:
        """Procesa un campo en el flujo secuencial conversacional"""
        conversacion = conversation_manager.get_conversacion(numero_telefono)
        campo_actual = conversation_manager.get_campo_siguiente(numero_telefono)
        
        if not campo_actual:
            # Todos los campos est√°n completos, proceder a confirmaci√≥n
            valido, error = conversation_manager.validar_y_guardar_datos(numero_telefono)
            
            if not valido:
                conversation_manager.update_estado(numero_telefono, EstadoConversacion.RECOLECTANDO_SECUENCIAL)
                primer_campo = conversation_manager.get_campo_siguiente(numero_telefono)
                return f"‚ùå Hay algunos errores en los datos:\n{error}\n\n{ChatbotRules._get_pregunta_campo_secuencial(primer_campo, conversacion.tipo_consulta)}"
            
            conversation_manager.update_estado(numero_telefono, EstadoConversacion.CONFIRMANDO)
            return ChatbotRules.get_mensaje_confirmacion(conversacion)
        
        # Verificar si el usuario quiere saltar el campo (solo para campos opcionales)
        if mensaje.strip().lower() in ['saltar', 'skip', 'no', 'n/a', 'na'] and campo_actual in ['email', 'direccion', 'horario_visita']:
            # Marcar campo como saltado
            conversation_manager.marcar_campo_completado(numero_telefono, campo_actual, "")
            confirmacion = ""  # Sin mensaje de confirmaci√≥n para campos saltados
        else:
            # Validar campo actual
            if not ChatbotRules._validar_campo_individual(campo_actual, mensaje.strip()):
                error_msg = ChatbotRules._get_error_campo_individual(campo_actual)
                return f"‚ùå {error_msg}\n{ChatbotRules._get_pregunta_campo_secuencial(campo_actual, conversacion.tipo_consulta)}"
            
            # Guardar campo v√°lido
            conversation_manager.marcar_campo_completado(numero_telefono, campo_actual, mensaje.strip())
            confirmacion = ChatbotRules._get_mensaje_confirmacion_campo(campo_actual, mensaje.strip())
        
        # VALIDACI√ìN GEOGR√ÅFICA para direcciones (solo si no se salt√≥ el campo)
        if campo_actual == 'direccion' and mensaje.strip().lower() not in ['saltar', 'skip', 'no', 'n/a', 'na']:
            ubicacion = ChatbotRules._validar_ubicacion_geografica(mensaje.strip()) #todo revisar
            
            if ubicacion == 'UNCLEAR':
                # Necesita validaci√≥n manual - guardar direcci√≥n pendiente
                conversation_manager.set_datos_temporales(numero_telefono, '_direccion_pendiente', mensaje.strip())
                conversation_manager.update_estado(numero_telefono, EstadoConversacion.VALIDANDO_UBICACION)
                
                confirmacion = ChatbotRules._get_mensaje_confirmacion_campo(campo_actual, mensaje.strip())
                return f"{confirmacion}\n{ChatbotRules._get_mensaje_seleccion_ubicacion()}"
        
        # La confirmaci√≥n ya se gener√≥ arriba seg√∫n si se salt√≥ o se valid√≥ el campo
        
        # Verificar si es el √∫ltimo campo
        if conversation_manager.es_ultimo_campo(numero_telefono, campo_actual):
            # Si hay una descripci√≥n inicial pre-guardada y este es el campo descripci√≥n, 
            # usar esa en lugar de pedir al usuario que escriba otra
            conversacion_temp = conversation_manager.get_conversacion(numero_telefono)
            descripcion_inicial = conversacion_temp.datos_temporales.get('_descripcion_inicial')
            
            if campo_actual == 'descripcion' and descripcion_inicial:
                # Usar la descripci√≥n inicial en lugar de la del usuario
                conversation_manager.marcar_campo_completado(numero_telefono, 'descripcion', descripcion_inicial)
                # Limpiar descripci√≥n temporal
                conversation_manager.set_datos_temporales(numero_telefono, '_descripcion_inicial', None)
                confirmacion = ChatbotRules._get_mensaje_confirmacion_campo('descripcion', descripcion_inicial)
            
            # Proceder a confirmaci√≥n final
            conversacion_actualizada = conversation_manager.get_conversacion(numero_telefono)
            valido, error = conversation_manager.validar_y_guardar_datos(numero_telefono)
            
            if not valido:
                return f"‚ùå Hay algunos errores en los datos:\n{error}"
            
            conversation_manager.update_estado(numero_telefono, EstadoConversacion.CONFIRMANDO)
            return f"{confirmacion}\n\n{ChatbotRules.get_mensaje_confirmacion(conversacion_actualizada)}"
        else:
            # Pedir siguiente campo
            siguiente_campo = conversation_manager.get_campo_siguiente(numero_telefono)
            siguiente_pregunta = ChatbotRules._get_pregunta_campo_secuencial(siguiente_campo, conversacion.tipo_consulta)
            return f"{confirmacion}\n{siguiente_pregunta}"
    
    @staticmethod
    def _procesar_campo_individual(numero_telefono: str, mensaje: str) -> str:
        conversacion = conversation_manager.get_conversacion(numero_telefono)
        campos_faltantes = conversacion.datos_temporales.get('_campos_faltantes', [])
        indice_actual = conversacion.datos_temporales.get('_campo_actual', 0)
        
        if indice_actual >= len(campos_faltantes):
            # Error, no deber√≠amos estar aqu√≠
            conversation_manager.update_estado(numero_telefono, EstadoConversacion.RECOLECTANDO_DATOS)
            return "ü§ñ Hubo un error. Escribe 'hola' para comenzar de nuevo."
        
        campo_actual = campos_faltantes[indice_actual]
        
        # Validar y guardar la respuesta
        if ChatbotRules._validar_campo_individual(campo_actual, mensaje.strip()):
            conversation_manager.set_datos_temporales(numero_telefono, campo_actual, mensaje.strip())
            
            # Avanzar al siguiente campo
            siguiente_indice = indice_actual + 1
            conversation_manager.set_datos_temporales(numero_telefono, '_campo_actual', siguiente_indice)
            
            if siguiente_indice >= len(campos_faltantes):
                # Ya tenemos todos los campos, proceder a validaci√≥n final
                conversation_manager.set_datos_temporales(numero_telefono, '_campos_faltantes', None)
                conversation_manager.set_datos_temporales(numero_telefono, '_campo_actual', None)
                
                valido, error = conversation_manager.validar_y_guardar_datos(numero_telefono)
                
                if not valido:
                    conversation_manager.update_estado(numero_telefono, EstadoConversacion.RECOLECTANDO_DATOS)
                    return f"‚ùå Hay algunos errores en los datos:\n\n{error}\n\nPor favor corrige y env√≠a la informaci√≥n nuevamente."
                
                conversation_manager.update_estado(numero_telefono, EstadoConversacion.CONFIRMANDO)
                return ChatbotRules.get_mensaje_confirmacion(conversacion)
            else:
                # Preguntar por el siguiente campo
                siguiente_campo = campos_faltantes[siguiente_indice]
                return f"‚úÖ Perfecto!\n\n{ChatbotRules._get_pregunta_campo_individual(siguiente_campo)}"
        else:
            # Campo inv√°lido, pedir de nuevo
            error_msg = ChatbotRules._get_error_campo_individual(campo_actual)
            return f"‚ùå {error_msg}\n\n{ChatbotRules._get_pregunta_campo_individual(campo_actual)}"
    
    @staticmethod
    def _validar_campo_individual(campo: str, valor: str) -> bool:
        if campo == 'email':
            import re
            email_pattern = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
            return bool(re.search(email_pattern, valor))
        elif campo == 'direccion':
            return len(valor) >= 5
        elif campo == 'horario_visita':
            return len(valor) >= 3
        elif campo == 'descripcion':
            return len(valor) >= 10
        return False
    
    @staticmethod
    def _get_error_campo_individual(campo: str) -> str:
        errores = {
            'email': "El email no tiene un formato v√°lido.",
            'direccion': "La direcci√≥n debe tener al menos 5 caracteres.",
            'horario_visita': "El horario debe tener al menos 3 caracteres.",
            'descripcion': "La descripci√≥n debe tener al menos 10 caracteres."
        }
        return errores.get(campo, "El formato no es v√°lido.")
    
    @staticmethod
    def _validar_ubicacion_geografica(direccion: str) -> str:
        """
        Valida si una direcci√≥n especifica CABA o Provincia usando comparaci√≥n de keywords
        Retorna: 'CABA', 'PROVINCIA', o 'UNCLEAR'
        """
        direccion_lower = direccion.lower()
        
        # Buscar keywords en la direcci√≥n
        try:
            for sinonimo in SINONIMOS_CABA:
                if sinonimo in direccion_lower:
                    return 'CABA'
            
            for sinonimo in SINONIMOS_PROVINCIA:
                if sinonimo in direccion_lower:
                    return 'PROVINCIA'
        except Exception:
            print('LOCATION ERROR: NO SE PUDO VALIDAR CON KEYWORDS SI ES CABA O PROVINCIA')
            return 'UNCLEAR'
            
        # Si no encuentra keywords, retornar UNCLEAR para que el usuario seleccione manualmente
        return 'UNCLEAR'
    
    @staticmethod
    def _get_mensaje_seleccion_ubicacion() -> str:
        return """üìç *¬øTu direcci√≥n es en...*
1Ô∏è‚É£ *CABA*
2Ô∏è‚É£ *Provincia de Buenos Aires*
"""
    
    @staticmethod
    def _procesar_seleccion_ubicacion(numero_telefono: str, mensaje: str) -> str:
        """
        Procesa la selecci√≥n del usuario para CABA o Provincia
        Acepta n√∫meros (1, 2) y texto (caba, provincia, capital federal, bs as, etc.)
        """
        conversacion = conversation_manager.get_conversacion(numero_telefono)
        direccion_original = conversacion.datos_temporales.get('_direccion_pendiente', '')
        
        # Normalizar entrada del usuario (con acentos y may√∫sculas)
        texto_normalizado = normalizar_texto(mensaje)
        
        # Verificar si es CABA (opci√≥n 1 o sin√≥nimos normalizados)
        if texto_normalizado == '1' or texto_normalizado in SINONIMOS_CABA_NORM:
            # Actualizar la direcci√≥n con CABA
            direccion_final = f"{direccion_original}, CABA"
            conversation_manager.set_datos_temporales(numero_telefono, 'direccion', direccion_final)
            conversation_manager.set_datos_temporales(numero_telefono, '_direccion_pendiente', None)
            
            # Continuar con el flujo normal
            return ChatbotRules._continuar_despues_validacion_ubicacion(numero_telefono)
            
        # Verificar si es Provincia (opci√≥n 2 o sin√≥nimos normalizados)
        elif texto_normalizado == '2' or texto_normalizado in SINONIMOS_PROVINCIA_NORM:
            # Actualizar la direcci√≥n con Provincia
            direccion_final = f"{direccion_original}, Provincia de Buenos Aires"
            conversation_manager.set_datos_temporales(numero_telefono, 'direccion', direccion_final)
            conversation_manager.set_datos_temporales(numero_telefono, '_direccion_pendiente', None)
            
            # Continuar con el flujo normal
            return ChatbotRules._continuar_despues_validacion_ubicacion(numero_telefono)
        else:
            return "‚ùå Por favor responde *1* para CABA, *2* para Provincia, o escribe el nombre de tu ubicaci√≥n (ej: CABA, Provincia, Capital Federal, Buenos Aires)."
    
    @staticmethod
    def _continuar_despues_validacion_ubicacion(numero_telefono: str) -> str:
        """
        Contin√∫a el flujo despu√©s de validar la ubicaci√≥n geogr√°fica
        """
        conversacion = conversation_manager.get_conversacion(numero_telefono)
        
        # Verificar si est√°bamos en flujo de datos individuales
        campos_faltantes = conversacion.datos_temporales.get('_campos_faltantes', [])
        indice_actual = conversacion.datos_temporales.get('_campo_actual', 0)
        
        if campos_faltantes and indice_actual is not None:
            # Volver al flujo de preguntas individuales
            conversation_manager.update_estado(numero_telefono, EstadoConversacion.RECOLECTANDO_DATOS_INDIVIDUALES)
            
            if indice_actual >= len(campos_faltantes):
                # Ya tenemos todos los campos, proceder a validaci√≥n final
                valido, error = conversation_manager.validar_y_guardar_datos(numero_telefono)
                
                if not valido:
                    conversation_manager.update_estado(numero_telefono, EstadoConversacion.RECOLECTANDO_DATOS)
                    return f"‚ùå Hay algunos errores en los datos:\n\n{error}\n\nPor favor corrige y env√≠a la informaci√≥n nuevamente."
                
                conversation_manager.update_estado(numero_telefono, EstadoConversacion.CONFIRMANDO)
                return ChatbotRules.get_mensaje_confirmacion(conversacion)
            else:
                # Continuar con el siguiente campo faltante
                siguiente_campo = campos_faltantes[indice_actual]
                return f"‚úÖ Perfecto!\n\n{ChatbotRules._get_pregunta_campo_individual(siguiente_campo)}"
        else:
            # VERIFICAR SI ESTAMOS EN FLUJO SECUENCIAL
            if conversacion.estado_anterior == EstadoConversacion.RECOLECTANDO_SECUENCIAL or len([k for k in conversacion.datos_temporales.keys() if not k.startswith('_')]) <= 2:
                # Continuar flujo secuencial - pedir siguiente campo
                conversation_manager.update_estado(numero_telefono, EstadoConversacion.RECOLECTANDO_SECUENCIAL)
                siguiente_campo = conversation_manager.get_campo_siguiente(numero_telefono)
                
                if siguiente_campo:
                    conversacion_actualizada = conversation_manager.get_conversacion(numero_telefono)
                    return ChatbotRules._get_pregunta_campo_secuencial(siguiente_campo, conversacion_actualizada.tipo_consulta)
                else:
                    # Todos los campos est√°n completos
                    valido, error = conversation_manager.validar_y_guardar_datos(numero_telefono)
                    
                    if not valido:
                        # Reportar validaci√≥n final fallida como fricci√≥n
                        try:
                            error_reporter.capture_experience_issue(
                                ErrorTrigger.VALIDATION_REPEAT,
                                {
                                    "conversation_id": numero_telefono,
                                    "numero_telefono": numero_telefono,
                                    "estado_actual": conversacion.estado,
                                    "estado_anterior": conversacion.estado_anterior,
                                    "tipo_consulta": conversacion.tipo_consulta,
                                    "validation_info": {"error": error},
                                }
                            )
                        except Exception:
                            pass
                        return f"‚ùå Hay algunos errores en los datos:\n{error}"
                    
                    conversation_manager.update_estado(numero_telefono, EstadoConversacion.CONFIRMANDO)
                    return ChatbotRules.get_mensaje_confirmacion(conversacion)
            else:
                # Flujo normal, proceder a confirmaci√≥n
                valido, error = conversation_manager.validar_y_guardar_datos(numero_telefono)
                
                if not valido:
                    conversation_manager.update_estado(numero_telefono, EstadoConversacion.RECOLECTANDO_DATOS)
                    return f"‚ùå Hay algunos errores en los datos:\n\n{error}\n\nPor favor corrige y env√≠a la informaci√≥n nuevamente."
                
                conversation_manager.update_estado(numero_telefono, EstadoConversacion.CONFIRMANDO)
                return ChatbotRules.get_mensaje_confirmacion(conversacion)
    
    @staticmethod
    def _extraer_datos_con_llm(mensaje: str) -> dict:
        """
        Usa el servicio NLU para extraer datos cuando el parsing b√°sico no es suficiente
        """
        try:
            from services.nlu_service import nlu_service
            return nlu_service.extraer_datos_estructurados(mensaje)
        except Exception as e:
            import logging
            logger = logging.getLogger(__name__)
            logger.error(f"Error en extracci√≥n LLM: {str(e)}")
            return {}
    
    @staticmethod
    def get_mensaje_final_exito() -> str:
        return """¬°Perfecto! Tu solicitud ha sido enviada exitosamente üì§.

Nuestro staff la revisar√° y se pondr√° en contacto con vos a la brevedad al e-mail proporcionado.

¬°Gracias por confiar en nosotros!, estamos para ayudarte ü§ùüèª

*Argenfuego SRL*.
"""
# _Para una nueva consulta, escribe "hola"._"""
    
    @staticmethod
    def get_mensaje_error_opcion() -> str:
        return """‚ùå No entend√≠ tu selecci√≥n. 

Por favor responde con:
‚Ä¢ *1* para Solicitar un presupuesto
‚Ä¢ *2* para Reportar una urgencia
‚Ä¢ *3* para Otras consultas

_üí° Tambi√©n puedes describir tu necesidad con tus propias palabras y yo intentar√© entenderte._"""
    
    @staticmethod
    def get_mensaje_datos_incompletos() -> str:
        return """‚ö†Ô∏è Parece que falta informaci√≥n importante. 

Necesito que me env√≠es en un mensaje:
üìß Email de contacto
üìç Direcci√≥n completa
üïí Horario de visita
üìù Descripci√≥n de lo que necesitas

Por favor env√≠ame todos estos datos juntos."""
    
    @staticmethod
    def _get_mensaje_pregunta_campo_a_corregir() -> str:
        return """‚ùå Entendido que hay informaci√≥n incorrecta.

¬øQu√© campo deseas corregir?
1Ô∏è‚É£ Email
2Ô∏è‚É£ Direcci√≥n
3Ô∏è‚É£ Horario de visita
4Ô∏è‚É£ Descripci√≥n
5Ô∏è‚É£ Todo (reiniciar todos los datos)

Responde con el n√∫mero del campo que deseas modificar."""
    
    @staticmethod
    def _procesar_correccion_campo(numero_telefono: str, mensaje: str) -> str:
        opciones_correccion = {
            '1': 'email',
            '2': 'direccion', 
            '3': 'horario_visita',
            '4': 'descripcion',
            '5': 'todo'
        }
        
        campo = opciones_correccion.get(mensaje)
        conversacion = conversation_manager.get_conversacion(numero_telefono)
        
        if not campo:
            return "‚ùå No entend√≠ tu selecci√≥n. " + ChatbotRules._get_mensaje_pregunta_campo_a_corregir()
        
        if campo == 'todo':
            # Reiniciar todos los datos
            conversation_manager.clear_datos_temporales(numero_telefono)
            conversation_manager.update_estado(numero_telefono, EstadoConversacion.RECOLECTANDO_DATOS)
            return f"‚úèÔ∏è Entendido. {ChatbotRules.get_mensaje_recoleccion_datos(conversacion.tipo_consulta)}"
        else:
            # Preparar para corregir solo un campo espec√≠fico
            conversation_manager.set_datos_temporales(numero_telefono, '_campo_a_corregir', campo)
            conversation_manager.update_estado(numero_telefono, EstadoConversacion.CORRIGIENDO_CAMPO)
            return f"‚úÖ Perfecto. Por favor env√≠a el nuevo valor para: {ChatbotRules._get_pregunta_campo_individual(campo)}"
        
    @staticmethod
    def _procesar_correccion_campo_especifico(numero_telefono: str, mensaje: str) -> str:
        conversacion = conversation_manager.get_conversacion(numero_telefono)
        campo = conversacion.datos_temporales.get('_campo_a_corregir')
        
        if not campo:
            # Error, volver al inicio
            conversation_manager.update_estado(numero_telefono, EstadoConversacion.ESPERANDO_OPCION)
            return "ü§ñ Hubo un error. Escribe 'hola' para comenzar de nuevo."
        
        # Validar y actualizar el campo espec√≠fico
        if ChatbotRules._validar_campo_individual(campo, mensaje.strip()):
            conversation_manager.set_datos_temporales(numero_telefono, campo, mensaje.strip())
            
            # Actualizar tambi√©n el objeto datos_contacto para que se refleje en la confirmaci√≥n
            valido, error = conversation_manager.validar_y_guardar_datos(numero_telefono)
            
            if not valido:
                # Esto no deber√≠a pasar porque acabamos de validar el campo individualmente
                return f"‚ùå Error al actualizar: {error}"
            
            # Limpiar campo temporal y volver a confirmaci√≥n
            conversation_manager.set_datos_temporales(numero_telefono, '_campo_a_corregir', None)
            conversation_manager.update_estado(numero_telefono, EstadoConversacion.CONFIRMANDO)
            
            # Obtener la conversaci√≥n actualizada
            conversacion_actualizada = conversation_manager.get_conversacion(numero_telefono)
            return f"‚úÖ Campo actualizado correctamente.\n\n{ChatbotRules.get_mensaje_confirmacion(conversacion_actualizada)}"
        else:
            # Campo inv√°lido, pedir de nuevo
            error_msg = ChatbotRules._get_error_campo_individual(campo)
            return f"‚ùå {error_msg}\n\nPor favor env√≠a un valor v√°lido para: {ChatbotRules._get_pregunta_campo_individual(campo)}"
    
    @staticmethod
    def procesar_mensaje(numero_telefono: str, mensaje: str, nombre_usuario: str = "") -> str:
        conversacion = conversation_manager.get_conversacion(numero_telefono)
        
        # Guardar nombre de usuario si es la primera vez que lo vemos
        if nombre_usuario and not conversacion.nombre_usuario:
            conversation_manager.set_nombre_usuario(numero_telefono, nombre_usuario)
        
        # INTERCEPTAR CONSULTAS DE CONTACTO EN CUALQUIER MOMENTO (Contextual Intent Interruption)
        from services.nlu_service import nlu_service
        if nlu_service.detectar_consulta_contacto(mensaje):
            respuesta_contacto = nlu_service.generar_respuesta_contacto(mensaje)
            
            # Si estamos en un flujo activo, agregar mensaje para continuar
            if conversacion.estado not in [EstadoConversacion.INICIO, EstadoConversacion.ESPERANDO_OPCION]:
                respuesta_contacto += "\n\nüí¨ *Ahora sigamos con tu consulta anterior...*"
            
            return respuesta_contacto
        
        # INTERCEPTAR SOLICITUD DE HABLAR CON HUMANO EN CUALQUIER MOMENTO
        if nlu_service.detectar_solicitud_humano(mensaje):
            respuesta_humano = nlu_service.generar_respuesta_humano(mensaje)
            if conversacion.estado not in [EstadoConversacion.INICIO, EstadoConversacion.ESPERANDO_OPCION]:
                respuesta_humano += "\n\nüí¨ *Si quer√©s, seguimos con tu consulta por ac√°...*"
            return respuesta_humano
        
        # INTERCEPTAR SOLICITUDES DE VOLVER AL MEN√ö EN CUALQUIER MOMENTO
        if ChatbotRules._detectar_volver_menu(mensaje) and conversacion.estado not in [EstadoConversacion.INICIO, EstadoConversacion.ESPERANDO_OPCION]:
            # Limpiar datos temporales y volver al men√∫
            conversation_manager.clear_datos_temporales(numero_telefono)
            conversation_manager.update_estado(numero_telefono, EstadoConversacion.ESPERANDO_OPCION)
            return "‚Ü©Ô∏è *Volviendo al men√∫ principal...*\n\n" + ChatbotRules.get_mensaje_inicial_personalizado(conversacion.nombre_usuario)
        
        mensaje_limpio = mensaje.strip().lower()
        
        if mensaje_limpio in ['hola', 'hi', 'hello', 'inicio', 'empezar']:
            conversation_manager.reset_conversacion(numero_telefono)
            conversacion = conversation_manager.get_conversacion(numero_telefono)
            
            # Guardar nombre de usuario en la nueva conversaci√≥n
            if nombre_usuario:
                conversation_manager.set_nombre_usuario(numero_telefono, nombre_usuario)
            
            conversation_manager.update_estado(numero_telefono, EstadoConversacion.ESPERANDO_OPCION)
            try:
                metrics_service.on_conversation_started()
            except Exception:
                pass
            
            # Enviar flujo de 3 mensajes: saludo + imagen + presentaci√≥n
            return ChatbotRules._enviar_flujo_saludo_completo(numero_telefono, nombre_usuario)
        
        if conversacion.estado == EstadoConversacion.INICIO:
            conversation_manager.update_estado(numero_telefono, EstadoConversacion.ESPERANDO_OPCION)
            return ChatbotRules._enviar_flujo_saludo_completo(numero_telefono, conversacion.nombre_usuario or nombre_usuario)
        
        elif conversacion.estado == EstadoConversacion.ESPERANDO_OPCION:
            return ChatbotRules._procesar_seleccion_opcion(numero_telefono, mensaje_limpio)
        
        elif conversacion.estado == EstadoConversacion.RECOLECTANDO_DATOS:
            return ChatbotRules._procesar_datos_contacto(numero_telefono, mensaje)
        
        elif conversacion.estado == EstadoConversacion.RECOLECTANDO_DATOS_INDIVIDUALES:
            return ChatbotRules._procesar_campo_individual(numero_telefono, mensaje)
        
        elif conversacion.estado == EstadoConversacion.RECOLECTANDO_SECUENCIAL:
            return ChatbotRules._procesar_campo_secuencial(numero_telefono, mensaje)
        
        elif conversacion.estado == EstadoConversacion.VALIDANDO_UBICACION:
            return ChatbotRules._procesar_seleccion_ubicacion(numero_telefono, mensaje_limpio)
        
        elif conversacion.estado == EstadoConversacion.CONFIRMANDO:
            return ChatbotRules._procesar_confirmacion(numero_telefono, mensaje_limpio)
        
        elif conversacion.estado == EstadoConversacion.CORRIGIENDO:
            return ChatbotRules._procesar_correccion_campo(numero_telefono, mensaje_limpio)
        
        elif conversacion.estado == EstadoConversacion.CORRIGIENDO_CAMPO:
            return ChatbotRules._procesar_correccion_campo_especifico(numero_telefono, mensaje)
        
        else:
            return "ü§ñ Hubo un error. Escribe 'hola' para comenzar de nuevo."
    
    @staticmethod
    def _procesar_seleccion_opcion(numero_telefono: str, mensaje: str) -> str:
        opciones = {
            '1': TipoConsulta.PRESUPUESTO,
            '2': TipoConsulta.URGENCIA,
            '3': TipoConsulta.OTRAS,
            'presupuesto': TipoConsulta.PRESUPUESTO,
            'urgencia': TipoConsulta.URGENCIA,
            'otras': TipoConsulta.OTRAS,
            'visita': TipoConsulta.OTRAS,  # Visitas t√©cnicas ahora van a OTRAS
            'consulta': TipoConsulta.OTRAS
        }
        
        tipo_consulta = opciones.get(mensaje)
        if tipo_consulta:
            conversation_manager.set_tipo_consulta(numero_telefono, tipo_consulta)
            try:
                metrics_service.on_intent(tipo_consulta.value)
            except Exception:
                pass
            
            # REDIRECCI√ìN INMEDIATA PARA URGENCIAS
            if tipo_consulta == TipoConsulta.URGENCIA:
                conversation_manager.update_estado(numero_telefono, EstadoConversacion.FINALIZADO)
                return get_urgency_redirect_message()
            
            # Para otras consultas, usar flujo secuencial conversacional
            conversation_manager.update_estado(numero_telefono, EstadoConversacion.RECOLECTANDO_SECUENCIAL)
            return ChatbotRules.get_mensaje_inicio_secuencial(tipo_consulta)
        else:
            # Fallback: usar NLU para mapear mensaje a intenci√≥n
            from services.nlu_service import nlu_service
            tipo_consulta_nlu = nlu_service.mapear_intencion(mensaje)
            
            if tipo_consulta_nlu:
                conversation_manager.set_tipo_consulta(numero_telefono, tipo_consulta_nlu)
                try:
                    metrics_service.on_intent(tipo_consulta_nlu.value)
                except Exception:
                    pass
                
                # REDIRECCI√ìN INMEDIATA PARA URGENCIAS (NLU)
                if tipo_consulta_nlu == TipoConsulta.URGENCIA:
                    conversation_manager.update_estado(numero_telefono, EstadoConversacion.FINALIZADO)
                    return f"‚úÖ Entend√≠ que tienes una urgencia.\n\n{get_urgency_redirect_message()}"
                
                # Para otras consultas, usar flujo secuencial conversacional
                # PRE-GUARDAR MENSAJE INICIAL COMO DESCRIPCI√ìN si es sustancial
                if len(mensaje.strip()) > 15:
                    conversation_manager.set_datos_temporales(numero_telefono, '_descripcion_inicial', mensaje.strip())
                
                conversation_manager.update_estado(numero_telefono, EstadoConversacion.RECOLECTANDO_SECUENCIAL)
                
                if tipo_consulta_nlu == TipoConsulta.OTRAS:
                    return ChatbotRules.get_mensaje_inicio_secuencial(tipo_consulta_nlu)
                else:
                    return f"¬°Listo! üìù Entend√≠ que necesit√°s {ChatbotRules._get_texto_tipo_consulta(tipo_consulta_nlu)}.\n\n{ChatbotRules.get_mensaje_inicio_secuencial(tipo_consulta_nlu)}"
            else:
                # Reportar intenci√≥n no clara (fricci√≥n NLU)
                try:
                    error_reporter.capture_experience_issue(
                        ErrorTrigger.NLU_UNCLEAR,
                        {
                            "conversation_id": numero_telefono,
                            "numero_telefono": numero_telefono,
                            "estado_actual": conversacion.estado,
                            "estado_anterior": conversacion.estado_anterior,
                            "nlu_snapshot": {"input": mensaje},
                            "recommended_action": "Revisar patrones y prompt de clasificaci√≥n",
                        }
                    )
                except Exception:
                    pass
                try:
                    metrics_service.on_nlu_unclear()
                except Exception:
                    pass
                return ChatbotRules.get_mensaje_error_opcion()
    
    @staticmethod
    def _procesar_datos_contacto(numero_telefono: str, mensaje: str) -> str:
        # ENFOQUE LLM-FIRST: Usar OpenAI como parser primario
        datos_parseados = {}
        
        # Intentar extracci√≥n LLM primero (m√°s potente para casos complejos)
        if len(mensaje) > 20:
            datos_llm = ChatbotRules._extraer_datos_con_llm(mensaje)
            if datos_llm:
                datos_parseados = datos_llm.copy()
        
        # Fallback: Si LLM no extrajo suficientes campos, usar parser b√°sico
        campos_encontrados_llm = sum(1 for v in datos_parseados.values() if v and v != "")
        if campos_encontrados_llm < 2:
            datos_basicos = ChatbotRules._parsear_datos_contacto_basico(mensaje)
            # Combinar resultados, dando prioridad a LLM pero completando con parsing b√°sico
            for key, value in datos_basicos.items():
                if value and not datos_parseados.get(key):
                    datos_parseados[key] = value
        
        # Limpiar el campo tipo_consulta que no necesitamos aqu√≠
        if 'tipo_consulta' in datos_parseados:
            del datos_parseados['tipo_consulta']
        
        # Guardar los datos que s√≠ se pudieron extraer
        campos_encontrados = []
        for key, value in datos_parseados.items():
            if value and value.strip():
                conversation_manager.set_datos_temporales(numero_telefono, key, value.strip())
                campos_encontrados.append(key)
        
        # VALIDACI√ìN GEOGR√ÅFICA: Si tenemos direcci√≥n, validar ubicaci√≥n
        if 'direccion' in campos_encontrados:
            direccion = datos_parseados['direccion']
            ubicacion = ChatbotRules._validar_ubicacion_geografica(direccion)
            
            if ubicacion == 'UNCLEAR':
                # Necesita validaci√≥n manual - guardar direcci√≥n pendiente y cambiar estado
                conversation_manager.set_datos_temporales(numero_telefono, '_direccion_pendiente', direccion)
                conversation_manager.update_estado(numero_telefono, EstadoConversacion.VALIDANDO_UBICACION)
                
                # Mostrar campos encontrados y preguntar ubicaci√≥n
                mensaje_encontrados = ""
                if len(campos_encontrados) > 1:  # M√°s campos adem√°s de direcci√≥n
                    nombres_campos = {
                        'email': 'üìß Email',
                        'direccion': 'üìç Direcci√≥n', 
                        'horario_visita': 'üïí Horario',
                        'descripcion': 'üìù Descripci√≥n'
                    }
                    campos_texto = [nombres_campos[campo] for campo in campos_encontrados if campo != 'direccion']
                    if campos_texto:
                        mensaje_encontrados = "Ya tengo:\n"
                        for campo in campos_texto:
                            mensaje_encontrados += f"{campo} ‚úÖ\n"
                
                return mensaje_encontrados + f"üìç Direcci√≥n detectada: *{direccion}*\n\n" + ChatbotRules._get_mensaje_seleccion_ubicacion()
        
        # Determinar qu√© campos faltan
        campos_requeridos = ['email', 'direccion', 'horario_visita', 'descripcion']
        campos_faltantes = [campo for campo in campos_requeridos if not datos_parseados.get(campo) or not datos_parseados.get(campo).strip()]
        
        if not campos_faltantes:
            # Todos los campos est√°n presentes, proceder con validaci√≥n final
            valido, error = conversation_manager.validar_y_guardar_datos(numero_telefono)
            
            if not valido:
                return f"‚ùå Hay algunos errores en los datos:\n\n{error}\n\nPor favor corrige y env√≠a la informaci√≥n nuevamente."
            
            conversacion = conversation_manager.get_conversacion(numero_telefono)
            conversation_manager.update_estado(numero_telefono, EstadoConversacion.CONFIRMANDO)
            return ChatbotRules.get_mensaje_confirmacion(conversacion)
        else:
            # Faltan campos, cambiar a modo de preguntas individuales
            conversation_manager.set_datos_temporales(numero_telefono, '_campos_faltantes', campos_faltantes)
            conversation_manager.set_datos_temporales(numero_telefono, '_campo_actual', 0)
            conversation_manager.update_estado(numero_telefono, EstadoConversacion.RECOLECTANDO_DATOS_INDIVIDUALES)
            
            # Mostrar qu√© se encontr√≥ y preguntar por el primer campo faltante
            mensaje_encontrados = ""
            conversacion = conversation_manager.get_conversacion(numero_telefono)
            
            # Incluir campos pre-guardados en datos_temporales
            campos_temporales = conversacion.datos_temporales or {}
            todos_los_campos = set(campos_encontrados)
            for campo in ['email', 'direccion', 'horario_visita', 'descripcion']:
                if campos_temporales.get(campo):
                    todos_los_campos.add(campo)
            
            if todos_los_campos:
                nombres_campos = {
                    'email': 'üìß Email',
                    'direccion': 'üìç Direcci√≥n', 
                    'horario_visita': 'üïí Horario',
                    'descripcion': 'üìù Descripci√≥n'
                }
                campos_texto = [nombres_campos[campo] for campo in todos_los_campos if campo in nombres_campos]
                mensaje_encontrados = "Ya tengo:\n"
                for campo in campos_texto:
                    mensaje_encontrados += f"{campo} ‚úÖ\n"
                mensaje_encontrados += "\n"
            
            return mensaje_encontrados + ChatbotRules._get_pregunta_campo_individual(campos_faltantes[0])
    
    @staticmethod
    def _procesar_confirmacion(numero_telefono: str, mensaje: str) -> str:
        if mensaje in ['si', 's√≠', 'yes', 'confirmo', 'ok', 'correcto']:
            conversation_manager.update_estado(numero_telefono, EstadoConversacion.ENVIANDO)
            return "‚è≥ Procesando tu solicitud..."
        elif mensaje in ['no', 'nope', 'incorrecto', 'error']:
            # Cambiar a estado de correcci√≥n y preguntar qu√© campo modificar
            conversation_manager.update_estado(numero_telefono, EstadoConversacion.CORRIGIENDO)
            return ChatbotRules._get_mensaje_pregunta_campo_a_corregir()
        else:
            return "ü§î Por favor responde *SI* para confirmar o *NO* para corregir la informaci√≥n."
    
    @staticmethod
    def _parsear_datos_contacto_basico(mensaje: str) -> dict:
        import re
        
        # Buscar email con regex mejorado
        email_pattern = r"[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}"
        email_match = re.search(email_pattern, mensaje)
        email = email_match.group() if email_match else ""
        
        # Dividir el mensaje en l√≠neas para buscar patrones
        lineas = [linea.strip() for linea in mensaje.split('\n') if linea.strip()]
        
        direccion = ""
        horario = ""
        descripcion = ""
        
        # Keywords mejoradas con scoring
        keywords_direccion = [
            'direcci√≥n', 'direccion', 'domicilio', 'ubicaci√≥n', 'ubicacion', 
            'domicilio', 'ubicado', 'calle', 'avenida', 'av.', 'av ', 'barrio'
        ]
        keywords_horario = [
            'horario', 'hora', 'disponible', 'visita', 'lunes', 'martes', 
            'mi√©rcoles', 'miercoles', 'jueves', 'viernes', 'sabado', 's√°bado', 'domingo', 'ma√±ana', 
            'tarde', 'noche', 'am', 'pm'
        ]
        keywords_descripcion = [
            'necesito', 'descripci√≥n', 'descripcion', 'detalle', 'matafuego',
            'extintor', 'incendio', 'seguridad', 'oficina', 'empresa', 'local'
        ]
        
        # Buscar patrones con scoring
        for linea in lineas:
            linea_lower = linea.lower()
            
            # Saltar l√≠neas que solo contienen email (ya lo tenemos)
            if email and linea.strip() == email:
                continue
            
            # Scoring para direccion
            score_direccion = sum(1 for kw in keywords_direccion if kw in linea_lower)
            # Scoring para horario
            score_horario = sum(1 for kw in keywords_horario if kw in linea_lower)
            # Scoring para descripcion
            score_descripcion = sum(1 for kw in keywords_descripcion if kw in linea_lower)
            
            # Determinar el valor extra√≠do de la l√≠nea
            valor_extraido = linea.split(':', 1)[-1].strip() if ':' in linea else linea
            
            # Solo procesar si el valor no es el email ya encontrado
            if valor_extraido == email:
                continue
                
            # Asignar basado en scores
            if score_direccion > 0 and score_direccion >= score_horario and score_direccion >= score_descripcion and not direccion:
                direccion = valor_extraido
            elif score_horario > 0 and score_horario >= score_direccion and score_horario >= score_descripcion and not horario:
                horario = valor_extraido
            elif score_descripcion > 0 and score_descripcion >= score_direccion and score_descripcion >= score_horario and not descripcion:
                descripcion = valor_extraido
            elif len(linea) > 15 and score_direccion == score_horario == score_descripcion == 0:
                # Sin keywords espec√≠ficas, clasificar por longitud y posici√≥n
                if not descripcion and any(word in linea_lower for word in ['necesito', 'quiero', 'para', 'equipar']):
                    descripcion = linea
                elif not direccion and len(linea) > 8:
                    direccion = linea
                elif not horario and len(linea) > 5:
                    horario = linea
        
        # Fallback: buscar por posici√≥n si no encontramos nada estructurado
        if not direccion and not horario and not descripcion and len(lineas) >= 3:
            mensaje_sin_email = mensaje
            if email:
                mensaje_sin_email = mensaje.replace(email, "").strip()
            
            partes = [parte.strip() for parte in mensaje_sin_email.split('\n') if parte.strip()]
            if len(partes) >= 3:
                direccion = partes[0] if not direccion else direccion
                horario = partes[1] if not horario else horario  
                descripcion = " ".join(partes[2:]) if not descripcion else descripcion
        
        # Validaci√≥n m√≠nima de longitud
        if len(direccion) < 5:
            direccion = ""
        if len(horario) < 3:
            horario = ""
        if len(descripcion) < 10:
            descripcion = ""
        
        return {
            'email': email,
            'direccion': direccion,
            'horario_visita': horario,
            'descripcion': descripcion
        }